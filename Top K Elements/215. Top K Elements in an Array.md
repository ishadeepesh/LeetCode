# 215. Kth Largest Element in an Array

## ‚úÖ Problem Statement

Given an integer array `nums` and an integer `k`, return the **kth largest element** in the array.

> It is the kth largest **by value**, not necessarily the kth distinct element.

---

## üß™ Examples

### Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Sorted: [1, 2, 3, 4, 5, 6] ‚Üí 2nd largest = 5

---

## üí°  Approach 1: Max Heap 

We can solve this without fully sorting the array using:
- **Heaps** (efficient for k-largest/smallest problems)
- **QuickSelect** (partition-based selection like QuickSort)

In this approach, we use a **max heap** to extract the top `k` largest values.

---

## ‚úÖ Code (Max Heap Approach)

```python
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        maxHeap = [-n for n in nums]      # Convert to max heap using negation
        heapq.heapify(maxHeap)            # Heapify the list
        res = 0

        for _ in range(k):                # Pop k times
            res = -heapq.heappop(maxHeap) # Revert negation to get original value

        return res
```
‚è± Time and Space Complexity
‚è± Time Complexity:
O(N + k log N):

O(N) to build the heap.

O(k log N) for popping k elements.

Note: If k << N, this is faster than sorting (O(N log N)).

‚è± Space Complexity:
O(N) for the heap (as all elements are stored).

## üí° Approach 2: Min Heap of Size k

### Intuition:
- Use a **min-heap** that maintains the top `k` largest elements.
- If the heap size exceeds `k`, pop the smallest.
- At the end, the root of the heap is the kth largest.

### ‚úÖ Python Code:
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        minHeap = nums[:k]
        heapq.heapify(minHeap)

        for num in nums[k:]:
            if num > minHeap[0]:
                heapq.heappop(minHeap)
                heapq.heappush(minHeap, num)

        return minHeap[0]
```
‚è± Time and Space:
‚è± Time: O(N log k)

‚è± Space: O(k)

## üí° Approach 3: Quickselect
### Intuition:
Based on QuickSort's partitioning.

We look for the (len(nums) - k)th smallest element instead of sorting all.

### ‚úÖ Python Code:
```python
import random

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def partition(left, right):
            pivot = nums[right]
            p = left
            for i in range(left, right):
                if nums[i] <= pivot:
                    nums[i], nums[p] = nums[p], nums[i]
                    p += 1
            nums[p], nums[right] = nums[right], nums[p]
            return p
        
        def quickselect(left, right, k_smallest):
            if left == right:
                return nums[left]

            pivot_index = random.randint(left, right)
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]
            pivot_index = partition(left, right)

            if pivot_index == k_smallest:
                return nums[pivot_index]
            elif pivot_index < k_smallest:
                return quickselect(pivot_index + 1, right, k_smallest)
            else:
                return quickselect(left, pivot_index - 1, k_smallest)

        return quickselect(0, len(nums) - 1, len(nums) - k)
```
‚è± Time and Space:
‚è± Time: Average O(N), Worst O(N¬≤)

‚è± Space: O(1) (in-place)

