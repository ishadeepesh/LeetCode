# 973. K Closest Points to Origin

## âœ… Problem Statement

Given an array of points `points[i] = [xi, yi]` on the X-Y plane and an integer `k`, return the **k closest points** to the origin `(0, 0)`.

The **distance** from a point `(x, y)` to the origin is:
distance = âˆš(xÂ² + yÂ²)

Return the `k` closest points. The result may be in **any order**.

---

## ðŸ§ª Example

### Input:
points = [[1,3],[-2,2]], k = 1

### Output:
[[-2,2]]

### Explanation:
- Distance from origin:
  - (1,3) â†’ âˆš(1Â² + 3Â²) = âˆš10
  - (-2,2) â†’ âˆš(4 + 4) = âˆš8

Since âˆš8 < âˆš10, the output is `[[-2,2]]`.

---

## ðŸ’¡ Approach: Max Heap (Size k)

### Intuition:
- To keep only the **k closest points**, use a **max heap** of size `k`.
- Push `(-distance, x, y)` into the heap.
  - We use negative distance to simulate a **max heap** using Pythonâ€™s min-heap.
- If heap size exceeds `k`, remove the farthest point.
- After processing all points, return the contents of the heap.

---

## âœ… Code 

```python
import heapq

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        heap = []
        for (x, y) in points:
            dist = -(x * x + y * y)  # Use negative distance for max heap
            if len(heap) == k:
                heapq.heappushpop(heap, (dist, x, y))  # Push and pop if heap is full
            else:
                heapq.heappush(heap, (dist, x, y))  # Add point to heap
        return [(x, y) for (dist, x, y) in heap]
```

#### ðŸ•’ Time Complexity  	O(N log k)
#### ðŸ’¾ Space Complexity  	O(k)

