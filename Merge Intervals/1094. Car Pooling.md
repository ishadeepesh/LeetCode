# üöó 1094. Car Pooling

## üìù Problem Statement

You are given a car with a certain **capacity** (number of seats), and a list of **trips**, where each trip is represented as:
[numPassengers, from, to]
This means that:
- `numPassengers` passengers are to be picked up at location `from`
- and dropped off at location `to`

The car **only drives east**, so all pickups and drop-offs must follow the order of increasing locations.

### ‚ùì Goal
Return **True** if it's possible to pick up and drop off all passengers for all trips **without exceeding the car's capacity at any time**. Otherwise, return **False**.

---

## üì• Example

**Input:**

trips = [[2,1,5],[3,3,7]]
capacity = 4
False
Explanation:

From km 1 to km 5, 2 passengers are onboard.

At km 3, 3 more passengers are picked up ‚Üí total = 5 passengers, which exceeds the capacity of 4.

## üí° Approach 1 (Min-Heap)
Sort the trips based on pickup (from) location.

Use a min-heap to keep track of ongoing trips:

Each heap element is [to, numPassengers]

The heap allows us to efficiently drop off passengers when their trip ends.

For each trip:

Drop off passengers whose destination (to) is before or at the current trip's from location.

Pick up new passengers.

If the current total exceeds capacity ‚Üí return False.

If all trips are processed without exceeding capacity ‚Üí return True.

## ‚úÖ Python Code
```python
import heapq

class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips.sort(key=lambda i: i[1])  # Sort by pickup location
        minHeap = []  # Min-heap of [endLocation, numPassengers]
        currPass = 0

        for numPass, start, end in trips:
            # Drop off passengers whose trips have ended
            while minHeap and minHeap[0][0] <= start:
                currPass -= heapq.heappop(minHeap)[1]

            # Pick up new passengers
            currPass += numPass
            if currPass > capacity:
                return False

            # Add new trip to the heap
            heapq.heappush(minHeap, [end, numPass])

        return True

```
‚è±Ô∏è Time Complexity
O(n log n):

Sorting trips: O(n log n)

Each push/pop in heap is log n, done at most once per trip

üíæ Space Complexity
O(n):

In the worst case, all trips are in progress and added to the heap

---

## üí° Approach 2 (Prefix-Sum)
1. Find the max far destination
2. Create diff_array of size=max+1
3. Record passenger changes
4. Calculate Prefix-Sum 

## ‚úÖ Python Code
```python

dmax= max(trip[2] for trip in trips)
        diff_array = [0] * (dmax+1)
        for trip in trips:
            diff_array[trip[1]]+=trip[0]
            diff_array[trip[2]]-=trip[0]
        return all(passenger_count <= capacity for passenger_count in accumulate(diff_array))

```
‚è±Ô∏è Time Complexity
O(n):

The time complexity is O(n + M), where n is the number of trips and M is the maximum end point in the trips. Breaking down the operations:

Finding the maximum end point: O(n) as it iterates through all trips
Initializing the difference array: O(M) to create an array of size M + 1
Processing all trips to update the difference array: O(n) as it iterates through each trip once
Computing the prefix sum using accumulate and checking capacity: O(M) as it processes the difference array
The overall time complexity is O(n + M). Since in this problem M ‚â§ 1000 is bounded by a constant, the time complexity can be considered O(n) when n is large.

üíæ Space Complexity
O(M):

The space complexity is O(M), where M is the maximum end point in the trips. This is due to the difference array d which has a size of M + 1. The accumulate function generates values on-the-fly without creating an additional array, so it doesn't add to the space complexity.
